name: Deployment Orchestrator

on:
  workflow_dispatch:
    inputs:
      deploy_infrastructure:
        description: 'Deploy infrastructure changes'
        required: false
        default: false
        type: boolean
      deploy_application:
        description: 'Deploy application'
        required: false
        default: true
        type: boolean
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'production'
        type: choice
        options:
          - staging
          - production
      force_infrastructure:
        description: 'Force infrastructure deployment even without changes'
        required: false
        default: false
        type: boolean

env:
  AWS_REGION: 'eu-west-1'

jobs:
  # Orchestrate infrastructure deployment
  infrastructure-orchestration:
    name: Infrastructure Deployment Orchestration
    runs-on: ubuntu-latest
    if: github.event.inputs.deploy_infrastructure == 'true'
    outputs:
      infrastructure-completed: ${{ steps.trigger.outputs.completed }}
      infrastructure-run-id: ${{ steps.trigger.outputs.run-id }}
    steps:
      - name: Trigger Infrastructure Deployment
        id: trigger
        uses: actions/github-script@v7
        with:
          script: |
            const response = await github.rest.actions.createWorkflowDispatch({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: 'infrastructure.yml',
              ref: context.ref,
              inputs: {
                environment: '${{ github.event.inputs.environment }}',
                action: '${{ github.event.inputs.force_infrastructure == "true" && "apply" || "plan" }}',
                auto_approve: '${{ github.event.inputs.force_infrastructure }}'
              }
            });
            
            console.log('Infrastructure deployment triggered');
            
            // Get the run ID (this is a bit tricky as the API doesn't return it directly)
            // We'll wait a moment and then find the most recent run
            await new Promise(resolve => setTimeout(resolve, 2000));
            
            const runs = await github.rest.actions.listWorkflowRuns({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: 'infrastructure.yml',
              per_page: 5
            });
            
            const latestRun = runs.data.workflow_runs[0];
            console.log(`Latest infrastructure run ID: ${latestRun.id}`);
            
            core.setOutput('completed', 'false');
            core.setOutput('run-id', latestRun.id);

      - name: Wait for Infrastructure Completion
        id: wait
        uses: actions/github-script@v7
        with:
          script: |
            const runId = '${{ steps.trigger.outputs.run-id }}';
            let completed = false;
            let attempts = 0;
            const maxAttempts = 60; // 30 minutes max
            
            while (!completed && attempts < maxAttempts) {
              attempts++;
              
              const run = await github.rest.actions.getWorkflowRun({
                owner: context.repo.owner,
                repo: context.repo.repo,
                run_id: runId
              });
              
              console.log(`Infrastructure run status: ${run.data.status} (attempt ${attempts})`);
              
              if (run.data.status === 'completed') {
                completed = true;
                console.log(`Infrastructure deployment completed with conclusion: ${run.data.conclusion}`);
                
                if (run.data.conclusion === 'success') {
                  core.setOutput('completed', 'true');
                  core.setOutput('success', 'true');
                } else {
                  core.setFailed(`Infrastructure deployment failed with conclusion: ${run.data.conclusion}`);
                }
              } else {
                await new Promise(resolve => setTimeout(resolve, 30000)); // Wait 30 seconds
              }
            }
            
            if (!completed) {
              core.setFailed('Infrastructure deployment timed out');
            }

  # Orchestrate application deployment
  application-orchestration:
    name: Application Deployment Orchestration
    runs-on: ubuntu-latest
    needs: infrastructure-orchestration
    if: |
      always() && 
      github.event.inputs.deploy_application == 'true' &&
      (needs.infrastructure-orchestration.result == 'success' || 
       needs.infrastructure-orchestration.result == 'skipped')
    outputs:
      application-completed: ${{ steps.trigger.outputs.completed }}
      application-run-id: ${{ steps.trigger.outputs.run-id }}
    steps:
      - name: Trigger Application Deployment
        id: trigger
        uses: actions/github-script@v7
        with:
          script: |
            const response = await github.rest.actions.createWorkflowDispatch({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: 'app-deploy.yml',
              ref: context.ref,
              inputs: {
                environment: '${{ github.event.inputs.environment }}',
                force_invalidation: 'true'
              }
            });
            
            console.log('Application deployment triggered');
            
            // Wait and find the latest run
            await new Promise(resolve => setTimeout(resolve, 2000));
            
            const runs = await github.rest.actions.listWorkflowRuns({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: 'app-deploy.yml',
              per_page: 5
            });
            
            const latestRun = runs.data.workflow_runs[0];
            console.log(`Latest application run ID: ${latestRun.id}`);
            
            core.setOutput('completed', 'false');
            core.setOutput('run-id', latestRun.id);

      - name: Wait for Application Completion
        id: wait
        uses: actions/github-script@v7
        with:
          script: |
            const runId = '${{ steps.trigger.outputs.run-id }}';
            let completed = false;
            let attempts = 0;
            const maxAttempts = 40; // 20 minutes max
            
            while (!completed && attempts < maxAttempts) {
              attempts++;
              
              const run = await github.rest.actions.getWorkflowRun({
                owner: context.repo.owner,
                repo: context.repo.repo,
                run_id: runId
              });
              
              console.log(`Application run status: ${run.data.status} (attempt ${attempts})`);
              
              if (run.data.status === 'completed') {
                completed = true;
                console.log(`Application deployment completed with conclusion: ${run.data.conclusion}`);
                
                if (run.data.conclusion === 'success') {
                  core.setOutput('completed', 'true');
                  core.setOutput('success', 'true');
                } else {
                  core.setFailed(`Application deployment failed with conclusion: ${run.data.conclusion}`);
                }
              } else {
                await new Promise(resolve => setTimeout(resolve, 30000)); // Wait 30 seconds
              }
            }
            
            if (!completed) {
              core.setFailed('Application deployment timed out');
            }

  # Deployment summary
  deployment-summary:
    name: Deployment Summary
    runs-on: ubuntu-latest
    needs: [infrastructure-orchestration, application-orchestration]
    if: always()
    steps:
      - name: Generate Deployment Summary
        run: |
          cat >> $GITHUB_STEP_SUMMARY << EOF
          ## 🚀 Orchestrated Deployment Summary
          
          **Environment:** ${{ github.event.inputs.environment }}
          **Timestamp:** $(date -u)
          
          ### 📊 Deployment Results
          
          **Infrastructure Deployment:**
          - **Requested:** ${{ github.event.inputs.deploy_infrastructure }}
          - **Status:** ${{ needs.infrastructure-orchestration.result || 'Skipped' }}
          - **Run ID:** ${{ needs.infrastructure-orchestration.outputs.infrastructure-run-id || 'N/A' }}
          
          **Application Deployment:**
          - **Requested:** ${{ github.event.inputs.deploy_application }}
          - **Status:** ${{ needs.application-orchestration.result || 'Skipped' }}
          - **Run ID:** ${{ needs.application-orchestration.outputs.application-run-id || 'N/A' }}
          
          ### 🔗 Related Workflows
          ${{ needs.infrastructure-orchestration.outputs.infrastructure-run-id && format('- [Infrastructure Deployment](https://github.com/{0}/{1}/actions/runs/{2})', github.repository_owner, github.event.repository.name, needs.infrastructure-orchestration.outputs.infrastructure-run-id) || '' }}
          ${{ needs.application-orchestration.outputs.application-run-id && format('- [Application Deployment](https://github.com/{0}/{1}/actions/runs/{2})', github.repository_owner, github.event.repository.name, needs.application-orchestration.outputs.application-run-id) || '' }}
          
          ### ✅ Overall Status
          ${{ (needs.infrastructure-orchestration.result == 'success' || needs.infrastructure-orchestration.result == 'skipped') && (needs.application-orchestration.result == 'success' || needs.application-orchestration.result == 'skipped') && '🎉 All requested deployments completed successfully!' || '❌ Some deployments failed or were cancelled' }}
          EOF