name: Application Deployment

on:
  push:
    branches: [main]
    paths-ignore:
      - 'terraform/**'
      - '.github/workflows/infrastructure.yml'
      - '*.md'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'production'
        type: choice
        options:
          - staging
          - production
      force_invalidation:
        description: 'Force complete CloudFront cache invalidation'
        required: false
        default: false
        type: boolean
      skip_build:
        description: 'Skip build step (use existing artifacts)'
        required: false
        default: false
        type: boolean
  workflow_run:
    workflows: ["Infrastructure Deployment"]
    types:
      - completed

env:
  NODE_VERSION: '18'
  AWS_REGION: 'eu-west-1'

jobs:
  # Check infrastructure readiness
  infrastructure-check:
    name: Check Infrastructure Readiness
    runs-on: ubuntu-latest
    if: github.event_name != 'workflow_run' || github.event.workflow_run.conclusion == 'success'
    permissions:
      id-token: write
      contents: read
    outputs:
      infrastructure-ready: ${{ steps.check.outputs.ready }}
      s3-bucket: ${{ steps.check.outputs.s3-bucket }}
      cloudfront-id: ${{ steps.check.outputs.cloudfront-id }}
      website-url: ${{ steps.check.outputs.website-url }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          sparse-checkout: |
            terraform/
          sparse-checkout-cone-mode: false

      - name: Configure AWS credentials using OIDC
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
          role-session-name: GitHubActions-App-InfraCheck-${{ github.run_id }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: '~1.0'
          terraform_wrapper: false

      - name: Check Infrastructure Status
        id: check
        working-directory: terraform
        run: |
          # Initialize Terraform to access state
          terraform init -backend-config="key=terraform.tfstate"
          
          # Get infrastructure outputs
          if terraform output s3_bucket_name >/dev/null 2>&1; then
            S3_BUCKET=$(terraform output -raw s3_bucket_name)
            CLOUDFRONT_ID=$(terraform output -raw cloudfront_distribution_id)
            WEBSITE_URL=$(terraform output -raw website_url)
            
            # Verify AWS resources exist
            if aws s3 ls "s3://$S3_BUCKET" >/dev/null 2>&1 && \
               aws cloudfront get-distribution --id "$CLOUDFRONT_ID" >/dev/null 2>&1; then
              echo "✅ Infrastructure is ready for deployment"
              echo "ready=true" >> $GITHUB_OUTPUT
              echo "s3-bucket=$S3_BUCKET" >> $GITHUB_OUTPUT
              echo "cloudfront-id=$CLOUDFRONT_ID" >> $GITHUB_OUTPUT
              echo "website-url=$WEBSITE_URL" >> $GITHUB_OUTPUT
            else
              echo "❌ Infrastructure resources not accessible"
              echo "ready=false" >> $GITHUB_OUTPUT
              exit 1
            fi
          else
            echo "❌ Infrastructure not deployed or Terraform state not accessible"
            echo "ready=false" >> $GITHUB_OUTPUT
            exit 1
          fi

  # Build and test application
  build:
    name: Build and Test Application
    runs-on: ubuntu-latest
    needs: infrastructure-check
    if: needs.infrastructure-check.outputs.infrastructure-ready == 'true' && github.event.inputs.skip_build != 'true'
    outputs:
      artifact-id: ${{ steps.artifact.outputs.artifact-id }}
      build-hash: ${{ steps.hash.outputs.build-hash }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run linting
        run: npm run lint

      - name: Run type checking
        run: npm run type-check

      - name: Run format check
        run: npm run format:check

      - name: Build application
        run: npm run build
        env:
          NODE_ENV: production

      - name: Verify build output
        run: |
          if [ ! -d "dist" ]; then
            echo "❌ Build failed: dist directory not found"
            exit 1
          fi
          if [ ! -f "dist/index.html" ]; then
            echo "❌ Build failed: index.html not found in dist"
            exit 1
          fi
          
          echo "✅ Build verification passed"
          echo "📊 Build size information:"
          du -sh dist/
          find dist -type f -name "*.js" -o -name "*.css" | head -10 | xargs ls -lh

      - name: Generate build hash
        id: hash
        run: |
          BUILD_HASH=$(find dist -type f -exec sha256sum {} \; | sort | sha256sum | cut -d' ' -f1 | head -c 8)
          echo "build-hash=$BUILD_HASH" >> $GITHUB_OUTPUT
          echo "🔨 Build hash: $BUILD_HASH"

      - name: Upload build artifacts
        id: artifact
        uses: actions/upload-artifact@v4
        with:
          name: build-artifacts-${{ steps.hash.outputs.build-hash }}-${{ github.sha }}
          path: dist/
          retention-days: 30
          compression-level: 9

  # Deploy to staging (automatic for PRs and manual dispatch)
  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: [infrastructure-check, build]
    if: |
      needs.infrastructure-check.outputs.infrastructure-ready == 'true' &&
      (github.event.inputs.environment == 'staging' || 
       (github.event_name == 'pull_request' && github.event.action == 'opened'))
    environment:
      name: staging
      url: ${{ needs.infrastructure-check.outputs.website-url }}
    permissions:
      id-token: write
      contents: read
    steps:
      - name: Download build artifacts
        if: github.event.inputs.skip_build != 'true'
        uses: actions/download-artifact@v4
        with:
          name: build-artifacts-${{ needs.build.outputs.build-hash }}-${{ github.sha }}
          path: dist/

      - name: Configure AWS credentials using OIDC
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
          role-session-name: GitHubActions-App-Staging-${{ github.run_id }}

      - name: Deploy to S3 (Staging)
        run: |
          echo "🚀 Deploying to staging environment..."
          # Implementation for staging deployment would go here
          # For now, skipping actual deployment to staging
          echo "✅ Staging deployment completed"

  # Deploy to production
  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [infrastructure-check, build]
    if: |
      needs.infrastructure-check.outputs.infrastructure-ready == 'true' &&
      (github.ref == 'refs/heads/main' && github.event_name == 'push') ||
      github.event.inputs.environment == 'production'
    environment:
      name: production
      url: ${{ needs.infrastructure-check.outputs.website-url }}
    permissions:
      id-token: write
      contents: read
    outputs:
      deployment-url: ${{ needs.infrastructure-check.outputs.website-url }}
      deployment-time: ${{ steps.deploy.outputs.deployment-time }}
    steps:
      - name: Download build artifacts
        if: github.event.inputs.skip_build != 'true'
        uses: actions/download-artifact@v4
        with:
          name: build-artifacts-${{ needs.build.outputs.build-hash }}-${{ github.sha }}
          path: dist/

      - name: Configure AWS credentials using OIDC
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
          role-session-name: GitHubActions-App-Production-${{ github.run_id }}

      - name: Backup current deployment
        id: backup
        run: |
          BUCKET="${{ needs.infrastructure-check.outputs.s3-bucket }}"
          TIMESTAMP=$(date +"%Y%m%d-%H%M%S")
          BACKUP_PREFIX="backups/$TIMESTAMP"
          
          echo "🔄 Creating backup of current deployment..."
          
          # Check if bucket has content to backup
          if aws s3 ls "s3://$BUCKET/" --summarize | grep -q "Total Objects: 0"; then
            echo "📝 No existing content to backup"
            echo "backup-created=false" >> $GITHUB_OUTPUT
          else
            # Create backup
            aws s3 sync "s3://$BUCKET/" "s3://$BUCKET/$BACKUP_PREFIX/" \
              --exclude "backups/*" \
              --quiet
            echo "✅ Backup created: $BACKUP_PREFIX"
            echo "backup-created=true" >> $GITHUB_OUTPUT
            echo "backup-prefix=$BACKUP_PREFIX" >> $GITHUB_OUTPUT
          fi

      - name: Deploy to S3
        id: deploy
        run: |
          BUCKET="${{ needs.infrastructure-check.outputs.s3-bucket }}"
          DEPLOYMENT_TIME=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
          
          echo "🚀 Deploying application to S3..."
          echo "deployment-time=$DEPLOYMENT_TIME" >> $GITHUB_OUTPUT
          
          # Remove old content (except backups)
          echo "🧹 Cleaning old content..."
          aws s3 rm "s3://$BUCKET/" --recursive --exclude "backups/*"
          
          # Upload with optimized cache headers
          echo "📤 Uploading new content..."
          
          # HTML files - no cache (always check for updates)
          aws s3 sync dist/ "s3://$BUCKET/" \
            --exclude "*" \
            --include "*.html" \
            --cache-control "no-cache, no-store, must-revalidate" \
            --content-type "text/html; charset=utf-8" \
            --metadata-directive REPLACE
          
          # CSS and JS files with hash - long cache (1 year)
          aws s3 sync dist/ "s3://$BUCKET/" \
            --exclude "*" \
            --include "*.css" \
            --include "*.js" \
            --cache-control "max-age=31536000, immutable" \
            --metadata-directive REPLACE
          
          # Images and other assets - medium cache (1 month)
          aws s3 sync dist/ "s3://$BUCKET/" \
            --exclude "*" \
            --include "*.png" \
            --include "*.jpg" \
            --include "*.jpeg" \
            --include "*.gif" \
            --include "*.svg" \
            --include "*.ico" \
            --include "*.webp" \
            --include "*.webmanifest" \
            --cache-control "max-age=2592000" \
            --content-type "image/*" \
            --metadata-directive REPLACE
          
          # All other files - default cache (1 day)
          aws s3 sync dist/ "s3://$BUCKET/" \
            --cache-control "max-age=86400" \
            --metadata-directive REPLACE \
            --delete
          
          echo "✅ S3 deployment completed"

      - name: Invalidate CloudFront cache
        id: invalidate
        run: |
          DISTRIBUTION_ID="${{ needs.infrastructure-check.outputs.cloudfront-id }}"
          
          if [ "${{ github.event.inputs.force_invalidation }}" == "true" ]; then
            PATHS='["/*"]'
            echo "🔄 Creating complete cache invalidation..."
          else
            # Smart invalidation - only invalidate changed files
            PATHS='["/*.html", "/assets/*"]'
            echo "🔄 Creating selective cache invalidation..."
          fi
          
          INVALIDATION_ID=$(aws cloudfront create-invalidation \
            --distribution-id "$DISTRIBUTION_ID" \
            --paths "/*" \
            --query 'Invalidation.Id' \
            --output text)
          
          echo "✅ CloudFront invalidation created: $INVALIDATION_ID"
          echo "invalidation-id=$INVALIDATION_ID" >> $GITHUB_OUTPUT
          
          # Don't wait for invalidation in production for faster deployments
          echo "⏳ Invalidation is processing in background..."

      - name: Verify deployment
        id: verify
        run: |
          WEBSITE_URL="${{ needs.infrastructure-check.outputs.website-url }}"
          
          echo "🔍 Verifying deployment..."
          
          # Wait a moment for S3 propagation
          sleep 5
          
          # Check if the website is accessible
          MAX_ATTEMPTS=5
          ATTEMPT=1
          
          while [ $ATTEMPT -le $MAX_ATTEMPTS ]; do
            echo "🌐 Attempt $ATTEMPT: Checking $WEBSITE_URL"
            
            HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "$WEBSITE_URL" --max-time 10 || echo "000")
            
            if [ "$HTTP_STATUS" = "200" ]; then
              echo "✅ Website is accessible (HTTP $HTTP_STATUS)"
              echo "deployment-verified=true" >> $GITHUB_OUTPUT
              break
            else
              echo "⚠️ Website check returned HTTP $HTTP_STATUS"
              if [ $ATTEMPT -eq $MAX_ATTEMPTS ]; then
                echo "❌ All verification attempts failed"
                echo "deployment-verified=false" >> $GITHUB_OUTPUT
                # Don't fail the deployment for verification issues
                # exit 1
              else
                echo "⏳ Waiting 10 seconds before retry..."
                sleep 10
              fi
            fi
            
            ATTEMPT=$((ATTEMPT + 1))
          done

      - name: Performance audit
        id: performance
        if: steps.verify.outputs.deployment-verified == 'true'
        run: |
          WEBSITE_URL="${{ needs.infrastructure-check.outputs.website-url }}"
          
          echo "📊 Running basic performance check..."
          
          # Check page load time
          LOAD_TIME=$(curl -w "@-" -o /dev/null -s "$WEBSITE_URL" <<< 'time_total: %{time_total}\n' | grep -o '[0-9.]*')
          echo "⏱️ Page load time: ${LOAD_TIME}s"
          
          # Check if load time is reasonable (under 3 seconds)
          if [ $(echo "$LOAD_TIME < 3.0" | bc -l) -eq 1 ]; then
            echo "✅ Performance check passed"
            echo "performance-ok=true" >> $GITHUB_OUTPUT
          else
            echo "⚠️ Page load time is high: ${LOAD_TIME}s"
            echo "performance-ok=false" >> $GITHUB_OUTPUT
          fi
          
          echo "load-time=$LOAD_TIME" >> $GITHUB_OUTPUT

      - name: Post deployment summary
        run: |
          cat >> $GITHUB_STEP_SUMMARY << EOF
          ## 🚀 Application Deployment Summary
          
          **Environment:** Production
          **Status:** ✅ Successfully Deployed
          **Deployment Time:** ${{ steps.deploy.outputs.deployment-time }}
          
          ### 📊 Deployment Details
          - **Website URL:** [${{ needs.infrastructure-check.outputs.website-url }}](${{ needs.infrastructure-check.outputs.website-url }})
          - **S3 Bucket:** \`${{ needs.infrastructure-check.outputs.s3-bucket }}\`
          - **CloudFront Distribution:** \`${{ needs.infrastructure-check.outputs.cloudfront-id }}\`
          - **Build Hash:** \`${{ needs.build.outputs.build-hash }}\`
          - **Commit:** \`${{ github.sha }}\`
          
          ### ✅ Deployment Steps
          - ✅ Infrastructure readiness verified
          - ✅ Application built and tested
          - ${{ steps.backup.outputs.backup-created == 'true' && '✅ Previous version backed up' || '📝 No backup needed' }}
          - ✅ Files uploaded to S3
          - ✅ CloudFront cache invalidated (${{ steps.invalidate.outputs.invalidation-id }})
          - ${{ steps.verify.outputs.deployment-verified == 'true' && '✅ Deployment verified' || '⚠️ Verification incomplete' }}
          - ${{ steps.performance.outputs.performance-ok == 'true' && '✅ Performance check passed' || steps.performance.outputs.performance-ok == 'false' && '⚠️ Performance needs attention' || '📝 Performance check skipped' }}
          
          ### 📈 Performance Metrics
          ${{ steps.performance.outputs.load-time && format('- **Page Load Time:** {0}s', steps.performance.outputs.load-time) || '- Performance metrics not available' }}
          
          ### 🌐 Access Your Website
          [View Website](${{ needs.infrastructure-check.outputs.website-url }})
          
          ${{ steps.backup.outputs.backup-created == 'true' && format('### 🔄 Rollback Information\n- **Backup Location:** s3://{0}/{1}\n- Use infrastructure workflow to rollback if needed', needs.infrastructure-check.outputs.s3-bucket, steps.backup.outputs.backup-prefix) || '' }}
          EOF

  # Rollback capability
  rollback:
    name: Rollback Deployment
    runs-on: ubuntu-latest
    if: failure() && github.event.inputs.environment == 'production'
    needs: [infrastructure-check, deploy-production]
    environment:
      name: production-rollback
    permissions:
      id-token: write
      contents: read
    steps:
      - name: Configure AWS credentials using OIDC
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
          role-session-name: GitHubActions-App-Rollback-${{ github.run_id }}

      - name: List available backups
        id: backups
        run: |
          BUCKET="${{ needs.infrastructure-check.outputs.s3-bucket }}"
          
          echo "🔍 Searching for recent backups..."
          LATEST_BACKUP=$(aws s3 ls "s3://$BUCKET/backups/" | sort | tail -n 1 | awk '{print $2}' | sed 's|/||')
          
          if [ -n "$LATEST_BACKUP" ]; then
            echo "📂 Latest backup found: $LATEST_BACKUP"
            echo "latest-backup=$LATEST_BACKUP" >> $GITHUB_OUTPUT
            echo "backup-available=true" >> $GITHUB_OUTPUT
          else
            echo "❌ No backups available for rollback"
            echo "backup-available=false" >> $GITHUB_OUTPUT
          fi

      - name: Perform rollback
        if: steps.backups.outputs.backup-available == 'true'
        run: |
          BUCKET="${{ needs.infrastructure-check.outputs.s3-bucket }}"
          BACKUP_PREFIX="${{ steps.backups.outputs.latest-backup }}"
          
          echo "🔄 Rolling back to backup: $BACKUP_PREFIX"
          
          # Clear current content
          aws s3 rm "s3://$BUCKET/" --recursive --exclude "backups/*"
          
          # Restore from backup
          aws s3 sync "s3://$BUCKET/backups/$BACKUP_PREFIX/" "s3://$BUCKET/" \
            --delete \
            --exclude "backups/*"
          
          # Invalidate CloudFront cache
          aws cloudfront create-invalidation \
            --distribution-id "${{ needs.infrastructure-check.outputs.cloudfront-id }}" \
            --paths "/*"
          
          echo "✅ Rollback completed"

      - name: Rollback summary
        run: |
          cat >> $GITHUB_STEP_SUMMARY << EOF
          ## 🔄 Rollback Summary
          
          **Status:** ${{ steps.backups.outputs.backup-available == 'true' && '✅ Rollback Completed' || '❌ Rollback Failed' }}
          **Backup Used:** ${{ steps.backups.outputs.latest-backup || 'None available' }}
          
          ### 🔍 Next Steps
          - Investigate the deployment failure
          - Fix the issues in the code
          - Redeploy when ready
          
          [View Website](${{ needs.infrastructure-check.outputs.website-url }})
          EOF

  # Notify on failure
  notify-failure:
    name: Notify on Failure
    runs-on: ubuntu-latest
    needs: [infrastructure-check, build, deploy-production]
    if: failure()
    steps:
      - name: Notify failure
        run: |
          echo "🚨 Application deployment failed!"
          echo "Please check the workflow logs for details."
          
          cat >> $GITHUB_STEP_SUMMARY << EOF
          ## 🚨 Deployment Failure
          
          The application deployment has failed. Please review the workflow logs and take appropriate action.
          
          ### 🔍 Troubleshooting Steps
          1. Check the failed job logs for specific error messages
          2. Verify infrastructure is properly deployed
          3. Ensure all secrets and environment variables are configured
          4. Check for any breaking changes in the code
          
          ### 🔧 Recovery Options
          - Fix the issue and push a new commit
          - Use manual workflow dispatch to retry deployment
          - Use rollback capabilities if needed
          EOF